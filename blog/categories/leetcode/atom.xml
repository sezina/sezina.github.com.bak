<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: LeetCode | Sezina]]></title>
  <link href="http://sezina.github.com/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="http://sezina.github.com/"/>
  <updated>2013-11-01T16:54:58+08:00</updated>
  <id>http://sezina.github.com/</id>
  <author>
    <name><![CDATA[Sezina]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[LeetCode --- Add Two Numbers]]></title>
    <link href="http://sezina.github.com/blog/2013/11/01/leetcode-add-two-numbers/"/>
    <updated>2013-11-01T16:46:00+08:00</updated>
    <id>http://sezina.github.com/blog/2013/11/01/leetcode-add-two-numbers</id>
    <content type="html"><![CDATA[<p>又来了一道a＋b的题目。</p>

<p>英文原题：</p>

<pre><code>  You are given two linked lists representing two 
non－negative numbers. The digits are stored in reverse
order and each of their nodes contain a single digit.
Add the two numbers and return it as a linked list.

**Input**: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
**Output**: 7 -&gt; 0 -&gt; 8
</code></pre>

<p>大意是：</p>

<pre><code>给定两个用链表表示的非负数，这两个数为逆序存储（即个位-&gt;十位-&gt;百位这样存储），
数字的每一位用一个节点表示，求和后将和以同样的方式组织并返回。
</code></pre>

<p>这道题是考察基本的指针链表，非常简单。</p>

<p>```cpp
/<em><em>
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode </em>next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 </em>/
class Solution {
public:</p>

<pre><code>ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
    // IMPORTANT: Please reset any member data you declared, as
    // the same Solution instance will be reused for each test case.
    int carry = 0;
    int temp_sum = 0;
    ListNode *result_l = NULL, *last_one;
    while (l1 != NULL &amp;&amp; l2 != NULL) {
        temp_sum = l1-&gt;val + l2-&gt;val + carry;
        if (temp_sum &gt; 9) {
            carry = 1;
            temp_sum -= 10;
        } else {
            carry = 0;
        }
        if (result_l == NULL) {
            result_l = last_one = new ListNode(temp_sum);
        } else {
            last_one-&gt;next = new ListNode(temp_sum);
            last_one = last_one-&gt;next;
        }
        l1 = l1-&gt;next;
        l2 = l2-&gt;next;
    }

    ListNode *copy_l;
    if (l1 != NULL) {
        copy_l = l1;
    } else {
        copy_l = l2;
    }

    while (copy_l != NULL) {
        temp_sum = copy_l-&gt;val + carry;;
        if (temp_sum &gt; 9) {
            carry = 1;
            temp_sum -= 10;
        } else {
            carry = 0;
        }
        last_one-&gt;next = new ListNode(temp_sum);
        last_one = last_one-&gt;next;
        copy_l = copy_l-&gt;next;
    }

    if (carry) {
        last_one-&gt;next = new ListNode(carry);
    }
    return result_l;
}
</code></pre>

<p>};
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LeetCode --- Two Sum]]></title>
    <link href="http://sezina.github.com/blog/2013/10/31/leetcode-two-sum/"/>
    <updated>2013-10-31T13:04:00+08:00</updated>
    <id>http://sezina.github.com/blog/2013/10/31/leetcode-two-sum</id>
    <content type="html"><![CDATA[<p>昨日惊闻LeetCode这东西，听说上面的OJ都是些面试题，又据说是去北美找工作的人都会上去刷刷题，于是带着作为技术人对硅谷无比向往的心情注册了个号开刷，准备在接下来的这一段上算法课时间里把它刷完（一个美好的愿景）。</p>

<p>首先，上一道和所有OJ的第一道a＋b一样的题：</p>

<pre><code>  Given an array of integers, find two numbers such
that they add up to a specific target number.
  The function twoSum should return indices of the
two numbers such that they add up to the target,
where index1 must be less than index2. Please note
that your returned answers (both index1 and index2)
are not zero-based.
  You may assume that each input would have exactly
one solution.

**Input**: numbers={2, 7, 11, 15}, target=9
**Output**: index1=1, index2=2
</code></pre>

<p>中文意思就是：</p>

<pre><code>给定一个数列，找到两个数，它们相加刚好等于给定的target的值。
函数twoSum 应该返回这两个数的下标indx1和index2，且要求index1 &lt; index2，注意，这里的下标不是从0开始的。

**示例输入**：numbers={2, 7, 11, 15}, target=9
**示例输出**：index1=1, index2=2
</code></pre>

<p>看完题意简单吧，就是a＋b的问题。我直接写了两个for循环对数组进行循环判断。下面是我的C++实现。</p>

<p>```cpp
class Solution {
public:</p>

<pre><code>vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) {
    // IMPORTANT: Please reset any member data you declared, as
    // the same Solution instance will be reused for each test case.
    vector&lt;int&gt; result;
    for (int i = 0; i &lt; numbers.size(); i++) {
        for (int j = i + 1; numbers[i] &lt;= target &amp;&amp; j &lt; numbers.size(); j++) {
            if (numbers[j] &lt;= target &amp;&amp; numbers[i] + numbers[j] == target) {
                result.push_back(i + 1);
                result.push_back(j + 1);
                break;
            }
        }
    }
    return result;
}
</code></pre>

<p>};
```</p>
]]></content>
  </entry>
  
</feed>
